# typed: strong

module ModernTreasury
  module Models
    class PaymentOrderCreateAsyncParams < ModernTreasury::Internal::Type::BaseModel
      extend ModernTreasury::Internal::Type::RequestParameters::Converter
      include ModernTreasury::Internal::Type::RequestParameters

      OrHash =
        T.type_alias do
          T.any(
            ModernTreasury::PaymentOrderCreateAsyncParams,
            ModernTreasury::Internal::AnyHash
          )
        end

      # Value in specified currency's smallest unit. e.g. $10 would be represented as
      # 1000 (cents). For RTP, the maximum amount allowed by the network is $100,000.
      sig { returns(Integer) }
      attr_accessor :amount

      # One of `credit`, `debit`. Describes the direction money is flowing in the
      # transaction. A `credit` moves money from your account to someone else's. A
      # `debit` pulls money from someone else's account to your own. Note that wire,
      # rtp, and check payments will always be `credit`.
      sig do
        returns(
          ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol
        )
      end
      attr_accessor :direction

      # The ID of one of your organization's internal accounts.
      sig { returns(String) }
      attr_accessor :originating_account_id

      # One of `ach`, `se_bankgirot`, `eft`, `wire`, `check`, `sen`, `book`, `rtp`,
      # `sepa`, `bacs`, `au_becs`, `interac`, `neft`, `nics`,
      # `nz_national_clearing_code`, `sic`, `signet`, `provexchange`, `zengin`.
      sig { returns(ModernTreasury::PaymentOrderType::OrSymbol) }
      attr_accessor :type

      sig do
        returns(
          T.nilable(ModernTreasury::PaymentOrderCreateAsyncParams::Accounting)
        )
      end
      attr_reader :accounting

      sig do
        params(
          accounting:
            ModernTreasury::PaymentOrderCreateAsyncParams::Accounting::OrHash
        ).void
      end
      attr_writer :accounting

      # The ID of one of your accounting categories. Note that these will only be
      # accessible if your accounting system has been connected.
      sig { returns(T.nilable(String)) }
      attr_accessor :accounting_category_id

      # The ID of one of your accounting ledger classes. Note that these will only be
      # accessible if your accounting system has been connected.
      sig { returns(T.nilable(String)) }
      attr_accessor :accounting_ledger_class_id

      # The party that will pay the fees for the payment order. See
      # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
      # differences between the options.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
          )
        )
      end
      attr_accessor :charge_bearer

      # Defaults to the currency of the originating account.
      sig { returns(T.nilable(ModernTreasury::Currency::OrSymbol)) }
      attr_reader :currency

      sig { params(currency: ModernTreasury::Currency::OrSymbol).void }
      attr_writer :currency

      # An optional description for internal use.
      sig { returns(T.nilable(String)) }
      attr_accessor :description

      # Date transactions are to be posted to the participants' account. Defaults to the
      # current business day or the next business day if the current day is a bank
      # holiday or weekend. Format: yyyy-mm-dd.
      sig { returns(T.nilable(Date)) }
      attr_reader :effective_date

      sig { params(effective_date: Date).void }
      attr_writer :effective_date

      # RFP payments require an expires_at. This value must be past the effective_date.
      sig { returns(T.nilable(Time)) }
      attr_accessor :expires_at

      # A payment type to fallback to if the original type is not valid for the
      # receiving account. Currently, this only supports falling back from RTP to ACH
      # (type=rtp and fallback_type=ach)
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol
          )
        )
      end
      attr_reader :fallback_type

      sig do
        params(
          fallback_type:
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol
        ).void
      end
      attr_writer :fallback_type

      # If present, indicates a specific foreign exchange contract number that has been
      # generated by your financial institution.
      sig { returns(T.nilable(String)) }
      attr_accessor :foreign_exchange_contract

      # Indicates the type of FX transfer to initiate, can be either
      # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
      # currency matches the originating account currency.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
          )
        )
      end
      attr_accessor :foreign_exchange_indicator

      # Specifies a ledger transaction object that will be created with the payment
      # order. If the ledger transaction cannot be created, then the payment order
      # creation will fail. The resulting ledger transaction will mirror the status of
      # the payment order.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction
          )
        )
      end
      attr_reader :ledger_transaction

      sig do
        params(
          ledger_transaction:
            ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::OrHash
        ).void
      end
      attr_writer :ledger_transaction

      # Either ledger_transaction or ledger_transaction_id can be provided. Only a
      # pending ledger transaction can be attached upon payment order creation. Once the
      # payment order is created, the status of the ledger transaction tracks the
      # payment order automatically.
      sig { returns(T.nilable(String)) }
      attr_reader :ledger_transaction_id

      sig { params(ledger_transaction_id: String).void }
      attr_writer :ledger_transaction_id

      # An array of line items that must sum up to the amount of the payment order.
      sig do
        returns(
          T.nilable(
            T::Array[ModernTreasury::PaymentOrderCreateAsyncParams::LineItem]
          )
        )
      end
      attr_reader :line_items

      sig do
        params(
          line_items:
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem::OrHash
            ]
        ).void
      end
      attr_writer :line_items

      # Additional data represented as key-value pairs. Both the key and value must be
      # strings.
      sig { returns(T.nilable(T::Hash[Symbol, String])) }
      attr_reader :metadata

      sig { params(metadata: T::Hash[Symbol, String]).void }
      attr_writer :metadata

      # A boolean to determine if NSF Protection is enabled for this payment order. Note
      # that this setting must also be turned on in your organization settings page.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :nsf_protected

      sig { params(nsf_protected: T::Boolean).void }
      attr_writer :nsf_protected

      # If present, this will replace your default company name on receiver's bank
      # statement. This field can only be used for ACH payments currently. For ACH, only
      # the first 16 characters of this string will be used. Any additional characters
      # will be truncated.
      sig { returns(T.nilable(String)) }
      attr_accessor :originating_party_name

      # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
      # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
      # an overnight check rather than standard mail.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol
          )
        )
      end
      attr_reader :priority

      sig do
        params(
          priority:
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol
        ).void
      end
      attr_writer :priority

      # If present, Modern Treasury will not process the payment until after this time.
      # If `process_after` is past the cutoff for `effective_date`, `process_after` will
      # take precedence and `effective_date` will automatically update to reflect the
      # earliest possible sending date after `process_after`. Format is ISO8601
      # timestamp.
      sig { returns(T.nilable(Time)) }
      attr_accessor :process_after

      # For `wire`, this is usually the purpose which is transmitted via the
      # "InstrForDbtrAgt" field in the ISO20022 file. For `eft`, this field is the 3
      # digit CPA Code that will be attached to the payment.
      sig { returns(T.nilable(String)) }
      attr_accessor :purpose

      # Either `receiving_account` or `receiving_account_id` must be present. When using
      # `receiving_account_id`, you may pass the id of an external account or an
      # internal account.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount
          )
        )
      end
      attr_reader :receiving_account

      sig do
        params(
          receiving_account:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::OrHash
        ).void
      end
      attr_writer :receiving_account

      # Either `receiving_account` or `receiving_account_id` must be present. When using
      # `receiving_account_id`, you may pass the id of an external account or an
      # internal account.
      sig { returns(T.nilable(String)) }
      attr_reader :receiving_account_id

      sig { params(receiving_account_id: String).void }
      attr_writer :receiving_account_id

      # For `ach`, this field will be passed through on an addenda record. For `wire`
      # payments the field will be passed through as the "Originator to Beneficiary
      # Information", also known as OBI or Fedwire tag 6000.
      sig { returns(T.nilable(String)) }
      attr_accessor :remittance_information

      # Send an email to the counterparty when the payment order is sent to the bank. If
      # `null`, `send_remittance_advice` on the Counterparty is used.
      sig { returns(T.nilable(T::Boolean)) }
      attr_accessor :send_remittance_advice

      # An optional descriptor which will appear in the receiver's statement. For
      # `check` payments this field will be used as the memo line. For `ach` the maximum
      # length is 10 characters. Note that for ACH payments, the name on your bank
      # account will be included automatically by the bank, so you can use the
      # characters for other useful information. For `eft` the maximum length is 15
      # characters.
      sig { returns(T.nilable(String)) }
      attr_accessor :statement_descriptor

      # An additional layer of classification for the type of payment order you are
      # doing. This field is only used for `ach` payment orders currently. For `ach`
      # payment orders, the `subtype` represents the SEC code. We currently support
      # `CCD`, `PPD`, `IAT`, `CTX`, `WEB`, `CIE`, and `TEL`.
      sig { returns(T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol)) }
      attr_accessor :subtype

      # A flag that determines whether a payment order should go through transaction
      # monitoring.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :transaction_monitoring_enabled

      sig { params(transaction_monitoring_enabled: T::Boolean).void }
      attr_writer :transaction_monitoring_enabled

      # Identifier of the ultimate originator of the payment order.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_originating_party_identifier

      # Name of the ultimate originator of the payment order.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_originating_party_name

      # Identifier of the ultimate funds recipient.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_receiving_party_identifier

      # Name of the ultimate funds recipient.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_receiving_party_name

      sig do
        params(
          amount: Integer,
          direction:
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol,
          originating_account_id: String,
          type: ModernTreasury::PaymentOrderType::OrSymbol,
          accounting:
            ModernTreasury::PaymentOrderCreateAsyncParams::Accounting::OrHash,
          accounting_category_id: T.nilable(String),
          accounting_ledger_class_id: T.nilable(String),
          charge_bearer:
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
            ),
          currency: ModernTreasury::Currency::OrSymbol,
          description: T.nilable(String),
          effective_date: Date,
          expires_at: T.nilable(Time),
          fallback_type:
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol,
          foreign_exchange_contract: T.nilable(String),
          foreign_exchange_indicator:
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
            ),
          ledger_transaction:
            ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::OrHash,
          ledger_transaction_id: String,
          line_items:
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem::OrHash
            ],
          metadata: T::Hash[Symbol, String],
          nsf_protected: T::Boolean,
          originating_party_name: T.nilable(String),
          priority:
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol,
          process_after: T.nilable(Time),
          purpose: T.nilable(String),
          receiving_account:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::OrHash,
          receiving_account_id: String,
          remittance_information: T.nilable(String),
          send_remittance_advice: T.nilable(T::Boolean),
          statement_descriptor: T.nilable(String),
          subtype: T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol),
          transaction_monitoring_enabled: T::Boolean,
          ultimate_originating_party_identifier: T.nilable(String),
          ultimate_originating_party_name: T.nilable(String),
          ultimate_receiving_party_identifier: T.nilable(String),
          ultimate_receiving_party_name: T.nilable(String),
          request_options: ModernTreasury::RequestOptions::OrHash
        ).returns(T.attached_class)
      end
      def self.new(
        # Value in specified currency's smallest unit. e.g. $10 would be represented as
        # 1000 (cents). For RTP, the maximum amount allowed by the network is $100,000.
        amount:,
        # One of `credit`, `debit`. Describes the direction money is flowing in the
        # transaction. A `credit` moves money from your account to someone else's. A
        # `debit` pulls money from someone else's account to your own. Note that wire,
        # rtp, and check payments will always be `credit`.
        direction:,
        # The ID of one of your organization's internal accounts.
        originating_account_id:,
        # One of `ach`, `se_bankgirot`, `eft`, `wire`, `check`, `sen`, `book`, `rtp`,
        # `sepa`, `bacs`, `au_becs`, `interac`, `neft`, `nics`,
        # `nz_national_clearing_code`, `sic`, `signet`, `provexchange`, `zengin`.
        type:,
        accounting: nil,
        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        accounting_category_id: nil,
        # The ID of one of your accounting ledger classes. Note that these will only be
        # accessible if your accounting system has been connected.
        accounting_ledger_class_id: nil,
        # The party that will pay the fees for the payment order. See
        # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
        # differences between the options.
        charge_bearer: nil,
        # Defaults to the currency of the originating account.
        currency: nil,
        # An optional description for internal use.
        description: nil,
        # Date transactions are to be posted to the participants' account. Defaults to the
        # current business day or the next business day if the current day is a bank
        # holiday or weekend. Format: yyyy-mm-dd.
        effective_date: nil,
        # RFP payments require an expires_at. This value must be past the effective_date.
        expires_at: nil,
        # A payment type to fallback to if the original type is not valid for the
        # receiving account. Currently, this only supports falling back from RTP to ACH
        # (type=rtp and fallback_type=ach)
        fallback_type: nil,
        # If present, indicates a specific foreign exchange contract number that has been
        # generated by your financial institution.
        foreign_exchange_contract: nil,
        # Indicates the type of FX transfer to initiate, can be either
        # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
        # currency matches the originating account currency.
        foreign_exchange_indicator: nil,
        # Specifies a ledger transaction object that will be created with the payment
        # order. If the ledger transaction cannot be created, then the payment order
        # creation will fail. The resulting ledger transaction will mirror the status of
        # the payment order.
        ledger_transaction: nil,
        # Either ledger_transaction or ledger_transaction_id can be provided. Only a
        # pending ledger transaction can be attached upon payment order creation. Once the
        # payment order is created, the status of the ledger transaction tracks the
        # payment order automatically.
        ledger_transaction_id: nil,
        # An array of line items that must sum up to the amount of the payment order.
        line_items: nil,
        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        metadata: nil,
        # A boolean to determine if NSF Protection is enabled for this payment order. Note
        # that this setting must also be turned on in your organization settings page.
        nsf_protected: nil,
        # If present, this will replace your default company name on receiver's bank
        # statement. This field can only be used for ACH payments currently. For ACH, only
        # the first 16 characters of this string will be used. Any additional characters
        # will be truncated.
        originating_party_name: nil,
        # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
        # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
        # an overnight check rather than standard mail.
        priority: nil,
        # If present, Modern Treasury will not process the payment until after this time.
        # If `process_after` is past the cutoff for `effective_date`, `process_after` will
        # take precedence and `effective_date` will automatically update to reflect the
        # earliest possible sending date after `process_after`. Format is ISO8601
        # timestamp.
        process_after: nil,
        # For `wire`, this is usually the purpose which is transmitted via the
        # "InstrForDbtrAgt" field in the ISO20022 file. For `eft`, this field is the 3
        # digit CPA Code that will be attached to the payment.
        purpose: nil,
        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        receiving_account: nil,
        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        receiving_account_id: nil,
        # For `ach`, this field will be passed through on an addenda record. For `wire`
        # payments the field will be passed through as the "Originator to Beneficiary
        # Information", also known as OBI or Fedwire tag 6000.
        remittance_information: nil,
        # Send an email to the counterparty when the payment order is sent to the bank. If
        # `null`, `send_remittance_advice` on the Counterparty is used.
        send_remittance_advice: nil,
        # An optional descriptor which will appear in the receiver's statement. For
        # `check` payments this field will be used as the memo line. For `ach` the maximum
        # length is 10 characters. Note that for ACH payments, the name on your bank
        # account will be included automatically by the bank, so you can use the
        # characters for other useful information. For `eft` the maximum length is 15
        # characters.
        statement_descriptor: nil,
        # An additional layer of classification for the type of payment order you are
        # doing. This field is only used for `ach` payment orders currently. For `ach`
        # payment orders, the `subtype` represents the SEC code. We currently support
        # `CCD`, `PPD`, `IAT`, `CTX`, `WEB`, `CIE`, and `TEL`.
        subtype: nil,
        # A flag that determines whether a payment order should go through transaction
        # monitoring.
        transaction_monitoring_enabled: nil,
        # Identifier of the ultimate originator of the payment order.
        ultimate_originating_party_identifier: nil,
        # Name of the ultimate originator of the payment order.
        ultimate_originating_party_name: nil,
        # Identifier of the ultimate funds recipient.
        ultimate_receiving_party_identifier: nil,
        # Name of the ultimate funds recipient.
        ultimate_receiving_party_name: nil,
        request_options: {}
      )
      end

      sig do
        override.returns(
          {
            amount: Integer,
            direction:
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol,
            originating_account_id: String,
            type: ModernTreasury::PaymentOrderType::OrSymbol,
            accounting:
              ModernTreasury::PaymentOrderCreateAsyncParams::Accounting,
            accounting_category_id: T.nilable(String),
            accounting_ledger_class_id: T.nilable(String),
            charge_bearer:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
              ),
            currency: ModernTreasury::Currency::OrSymbol,
            description: T.nilable(String),
            effective_date: Date,
            expires_at: T.nilable(Time),
            fallback_type:
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol,
            foreign_exchange_contract: T.nilable(String),
            foreign_exchange_indicator:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
              ),
            ledger_transaction:
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction,
            ledger_transaction_id: String,
            line_items:
              T::Array[ModernTreasury::PaymentOrderCreateAsyncParams::LineItem],
            metadata: T::Hash[Symbol, String],
            nsf_protected: T::Boolean,
            originating_party_name: T.nilable(String),
            priority:
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol,
            process_after: T.nilable(Time),
            purpose: T.nilable(String),
            receiving_account:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount,
            receiving_account_id: String,
            remittance_information: T.nilable(String),
            send_remittance_advice: T.nilable(T::Boolean),
            statement_descriptor: T.nilable(String),
            subtype: T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol),
            transaction_monitoring_enabled: T::Boolean,
            ultimate_originating_party_identifier: T.nilable(String),
            ultimate_originating_party_name: T.nilable(String),
            ultimate_receiving_party_identifier: T.nilable(String),
            ultimate_receiving_party_name: T.nilable(String),
            request_options: ModernTreasury::RequestOptions
          }
        )
      end
      def to_hash
      end

      # One of `credit`, `debit`. Describes the direction money is flowing in the
      # transaction. A `credit` moves money from your account to someone else's. A
      # `debit` pulls money from someone else's account to your own. Note that wire,
      # rtp, and check payments will always be `credit`.
      module Direction
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        CREDIT =
          T.let(
            :credit,
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
          )
        DEBIT =
          T.let(
            :debit,
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class Accounting < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::Accounting,
              ModernTreasury::Internal::AnyHash
            )
          end

        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :account_id

        # The ID of one of the class objects in your accounting system. Class objects
        # track segments of your business independent of client or project. Note that
        # these will only be accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :class_id

        sig do
          params(
            account_id: T.nilable(String),
            class_id: T.nilable(String)
          ).returns(T.attached_class)
        end
        def self.new(
          # The ID of one of your accounting categories. Note that these will only be
          # accessible if your accounting system has been connected.
          account_id: nil,
          # The ID of one of the class objects in your accounting system. Class objects
          # track segments of your business independent of client or project. Note that
          # these will only be accessible if your accounting system has been connected.
          class_id: nil
        )
        end

        sig do
          override.returns(
            { account_id: T.nilable(String), class_id: T.nilable(String) }
          )
        end
        def to_hash
        end
      end

      # The party that will pay the fees for the payment order. See
      # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
      # differences between the options.
      module ChargeBearer
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        SHARED =
          T.let(
            :shared,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )
        SENDER =
          T.let(
            :sender,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )
        RECEIVER =
          T.let(
            :receiver,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      # A payment type to fallback to if the original type is not valid for the
      # receiving account. Currently, this only supports falling back from RTP to ACH
      # (type=rtp and fallback_type=ach)
      module FallbackType
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        ACH =
          T.let(
            :ach,
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      # Indicates the type of FX transfer to initiate, can be either
      # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
      # currency matches the originating account currency.
      module ForeignExchangeIndicator
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        FIXED_TO_VARIABLE =
          T.let(
            :fixed_to_variable,
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
          )
        VARIABLE_TO_FIXED =
          T.let(
            :variable_to_fixed,
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class LedgerTransaction < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction,
              ModernTreasury::Internal::AnyHash
            )
          end

        # An array of ledger entry objects.
        sig do
          returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerEntry
            ]
          )
        end
        attr_accessor :ledger_entries

        # An optional description for internal use.
        sig { returns(T.nilable(String)) }
        attr_accessor :description

        # The timestamp (ISO8601 format) at which the ledger transaction happened for
        # reporting purposes.
        sig { returns(T.nilable(Time)) }
        attr_reader :effective_at

        sig { params(effective_at: Time).void }
        attr_writer :effective_at

        # The date (YYYY-MM-DD) on which the ledger transaction happened for reporting
        # purposes.
        sig { returns(T.nilable(Date)) }
        attr_reader :effective_date

        sig { params(effective_date: Date).void }
        attr_writer :effective_date

        # A unique string to represent the ledger transaction. Only one pending or posted
        # ledger transaction may have this ID in the ledger.
        sig { returns(T.nilable(String)) }
        attr_reader :external_id

        sig { params(external_id: String).void }
        attr_writer :external_id

        # If the ledger transaction can be reconciled to another object in Modern
        # Treasury, the id will be populated here, otherwise null.
        sig { returns(T.nilable(String)) }
        attr_reader :ledgerable_id

        sig { params(ledgerable_id: String).void }
        attr_writer :ledgerable_id

        # If the ledger transaction can be reconciled to another object in Modern
        # Treasury, the type will be populated here, otherwise null. This can be one of
        # payment_order, incoming_payment_detail, expected_payment, return, paper_item, or
        # reversal.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::OrSymbol
            )
          )
        end
        attr_reader :ledgerable_type

        sig do
          params(
            ledgerable_type:
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::OrSymbol
          ).void
        end
        attr_writer :ledgerable_type

        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        sig { returns(T.nilable(T::Hash[Symbol, String])) }
        attr_reader :metadata

        sig { params(metadata: T::Hash[Symbol, String]).void }
        attr_writer :metadata

        # To post a ledger transaction at creation, use `posted`.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::OrSymbol
            )
          )
        end
        attr_reader :status

        sig do
          params(
            status:
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::OrSymbol
          ).void
        end
        attr_writer :status

        # Specifies a ledger transaction object that will be created with the payment
        # order. If the ledger transaction cannot be created, then the payment order
        # creation will fail. The resulting ledger transaction will mirror the status of
        # the payment order.
        sig do
          params(
            ledger_entries:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerEntry::OrHash
              ],
            description: T.nilable(String),
            effective_at: Time,
            effective_date: Date,
            external_id: String,
            ledgerable_id: String,
            ledgerable_type:
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::OrSymbol,
            metadata: T::Hash[Symbol, String],
            status:
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::OrSymbol
          ).returns(T.attached_class)
        end
        def self.new(
          # An array of ledger entry objects.
          ledger_entries:,
          # An optional description for internal use.
          description: nil,
          # The timestamp (ISO8601 format) at which the ledger transaction happened for
          # reporting purposes.
          effective_at: nil,
          # The date (YYYY-MM-DD) on which the ledger transaction happened for reporting
          # purposes.
          effective_date: nil,
          # A unique string to represent the ledger transaction. Only one pending or posted
          # ledger transaction may have this ID in the ledger.
          external_id: nil,
          # If the ledger transaction can be reconciled to another object in Modern
          # Treasury, the id will be populated here, otherwise null.
          ledgerable_id: nil,
          # If the ledger transaction can be reconciled to another object in Modern
          # Treasury, the type will be populated here, otherwise null. This can be one of
          # payment_order, incoming_payment_detail, expected_payment, return, paper_item, or
          # reversal.
          ledgerable_type: nil,
          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          metadata: nil,
          # To post a ledger transaction at creation, use `posted`.
          status: nil
        )
        end

        sig do
          override.returns(
            {
              ledger_entries:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerEntry
                ],
              description: T.nilable(String),
              effective_at: Time,
              effective_date: Date,
              external_id: String,
              ledgerable_id: String,
              ledgerable_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::OrSymbol,
              metadata: T::Hash[Symbol, String],
              status:
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::OrSymbol
            }
          )
        end
        def to_hash
        end

        class LedgerEntry < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerEntry,
                ModernTreasury::Internal::AnyHash
              )
            end

          # Value in specified currency's smallest unit. e.g. $10 would be represented
          # as 1000. Can be any integer up to 36 digits.
          sig { returns(Integer) }
          attr_accessor :amount

          # One of `credit`, `debit`. Describes the direction money is flowing in the
          # transaction. A `credit` moves money from your account to someone else's. A
          # `debit` pulls money from someone else's account to your own. Note that wire,
          # rtp, and check payments will always be `credit`.
          sig { returns(ModernTreasury::TransactionDirection::OrSymbol) }
          attr_accessor :direction

          # The ledger account that this ledger entry is associated with.
          sig { returns(String) }
          attr_accessor :ledger_account_id

          # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
          # account’s available balance. If any of these conditions would be false after the
          # transaction is created, the entire call will fail with error code 422.
          sig { returns(T.nilable(T::Hash[Symbol, Integer])) }
          attr_accessor :available_balance_amount

          # Lock version of the ledger account. This can be passed when creating a ledger
          # transaction to only succeed if no ledger transactions have posted since the
          # given version. See our post about Designing the Ledgers API with Optimistic
          # Locking for more details.
          sig { returns(T.nilable(Integer)) }
          attr_accessor :lock_version

          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          sig { returns(T.nilable(T::Hash[Symbol, String])) }
          attr_reader :metadata

          sig { params(metadata: T::Hash[Symbol, String]).void }
          attr_writer :metadata

          # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
          # account’s pending balance. If any of these conditions would be false after the
          # transaction is created, the entire call will fail with error code 422.
          sig { returns(T.nilable(T::Hash[Symbol, Integer])) }
          attr_accessor :pending_balance_amount

          # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
          # account’s posted balance. If any of these conditions would be false after the
          # transaction is created, the entire call will fail with error code 422.
          sig { returns(T.nilable(T::Hash[Symbol, Integer])) }
          attr_accessor :posted_balance_amount

          # If true, response will include the balance of the associated ledger account for
          # the entry.
          sig { returns(T.nilable(T::Boolean)) }
          attr_accessor :show_resulting_ledger_account_balances

          sig do
            params(
              amount: Integer,
              direction: ModernTreasury::TransactionDirection::OrSymbol,
              ledger_account_id: String,
              available_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
              lock_version: T.nilable(Integer),
              metadata: T::Hash[Symbol, String],
              pending_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
              posted_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
              show_resulting_ledger_account_balances: T.nilable(T::Boolean)
            ).returns(T.attached_class)
          end
          def self.new(
            # Value in specified currency's smallest unit. e.g. $10 would be represented
            # as 1000. Can be any integer up to 36 digits.
            amount:,
            # One of `credit`, `debit`. Describes the direction money is flowing in the
            # transaction. A `credit` moves money from your account to someone else's. A
            # `debit` pulls money from someone else's account to your own. Note that wire,
            # rtp, and check payments will always be `credit`.
            direction:,
            # The ledger account that this ledger entry is associated with.
            ledger_account_id:,
            # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
            # account’s available balance. If any of these conditions would be false after the
            # transaction is created, the entire call will fail with error code 422.
            available_balance_amount: nil,
            # Lock version of the ledger account. This can be passed when creating a ledger
            # transaction to only succeed if no ledger transactions have posted since the
            # given version. See our post about Designing the Ledgers API with Optimistic
            # Locking for more details.
            lock_version: nil,
            # Additional data represented as key-value pairs. Both the key and value must be
            # strings.
            metadata: nil,
            # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
            # account’s pending balance. If any of these conditions would be false after the
            # transaction is created, the entire call will fail with error code 422.
            pending_balance_amount: nil,
            # Use `gt` (>), `gte` (>=), `lt` (<), `lte` (<=), or `eq` (=) to lock on the
            # account’s posted balance. If any of these conditions would be false after the
            # transaction is created, the entire call will fail with error code 422.
            posted_balance_amount: nil,
            # If true, response will include the balance of the associated ledger account for
            # the entry.
            show_resulting_ledger_account_balances: nil
          )
          end

          sig do
            override.returns(
              {
                amount: Integer,
                direction: ModernTreasury::TransactionDirection::OrSymbol,
                ledger_account_id: String,
                available_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
                lock_version: T.nilable(Integer),
                metadata: T::Hash[Symbol, String],
                pending_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
                posted_balance_amount: T.nilable(T::Hash[Symbol, Integer]),
                show_resulting_ledger_account_balances: T.nilable(T::Boolean)
              }
            )
          end
          def to_hash
          end
        end

        # If the ledger transaction can be reconciled to another object in Modern
        # Treasury, the type will be populated here, otherwise null. This can be one of
        # payment_order, incoming_payment_detail, expected_payment, return, paper_item, or
        # reversal.
        module LedgerableType
          extend ModernTreasury::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias do
              T.all(
                Symbol,
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType
              )
            end
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          EXPECTED_PAYMENT =
            T.let(
              :expected_payment,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )
          INCOMING_PAYMENT_DETAIL =
            T.let(
              :incoming_payment_detail,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )
          PAPER_ITEM =
            T.let(
              :paper_item,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )
          PAYMENT_ORDER =
            T.let(
              :payment_order,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )
          RETURN =
            T.let(
              :return,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )
          REVERSAL =
            T.let(
              :reversal,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
            )

          sig do
            override.returns(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::LedgerableType::TaggedSymbol
              ]
            )
          end
          def self.values
          end
        end

        # To post a ledger transaction at creation, use `posted`.
        module Status
          extend ModernTreasury::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias do
              T.all(
                Symbol,
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status
              )
            end
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          ARCHIVED =
            T.let(
              :archived,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::TaggedSymbol
            )
          PENDING =
            T.let(
              :pending,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::TaggedSymbol
            )
          POSTED =
            T.let(
              :posted,
              ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::TaggedSymbol
            )

          sig do
            override.returns(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::LedgerTransaction::Status::TaggedSymbol
              ]
            )
          end
          def self.values
          end
        end
      end

      class LineItem < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem,
              ModernTreasury::Internal::AnyHash
            )
          end

        # Value in specified currency's smallest unit. e.g. $10 would be represented
        # as 1000.
        sig { returns(Integer) }
        attr_accessor :amount

        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :accounting_category_id

        # A free-form description of the line item.
        sig { returns(T.nilable(String)) }
        attr_accessor :description

        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        sig { returns(T.nilable(T::Hash[Symbol, String])) }
        attr_reader :metadata

        sig { params(metadata: T::Hash[Symbol, String]).void }
        attr_writer :metadata

        sig do
          params(
            amount: Integer,
            accounting_category_id: T.nilable(String),
            description: T.nilable(String),
            metadata: T::Hash[Symbol, String]
          ).returns(T.attached_class)
        end
        def self.new(
          # Value in specified currency's smallest unit. e.g. $10 would be represented
          # as 1000.
          amount:,
          # The ID of one of your accounting categories. Note that these will only be
          # accessible if your accounting system has been connected.
          accounting_category_id: nil,
          # A free-form description of the line item.
          description: nil,
          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          metadata: nil
        )
        end

        sig do
          override.returns(
            {
              amount: Integer,
              accounting_category_id: T.nilable(String),
              description: T.nilable(String),
              metadata: T::Hash[Symbol, String]
            }
          )
        end
        def to_hash
        end
      end

      # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
      # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
      # an overnight check rather than standard mail.
      module Priority
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        HIGH =
          T.let(
            :high,
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
          )
        NORMAL =
          T.let(
            :normal,
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class ReceivingAccount < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount,
              ModernTreasury::Internal::AnyHash
            )
          end

        sig do
          returns(
            T.nilable(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail
              ]
            )
          )
        end
        attr_reader :account_details

        sig do
          params(
            account_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::OrHash
              ]
          ).void
        end
        attr_writer :account_details

        # Can be `checking`, `savings` or `other`.
        sig do
          returns(T.nilable(ModernTreasury::ExternalAccountType::OrSymbol))
        end
        attr_reader :account_type

        sig do
          params(
            account_type: ModernTreasury::ExternalAccountType::OrSymbol
          ).void
        end
        attr_writer :account_type

        sig do
          returns(
            T.nilable(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail
              ]
            )
          )
        end
        attr_reader :contact_details

        sig do
          params(
            contact_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::OrHash
              ]
          ).void
        end
        attr_writer :contact_details

        # Specifies a ledger account object that will be created with the external
        # account. The resulting ledger account is linked to the external account for
        # auto-ledgering Payment objects. See
        # https://docs.moderntreasury.com/docs/linking-to-other-modern-treasury-objects
        # for more details.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount
            )
          )
        end
        attr_reader :ledger_account

        sig do
          params(
            ledger_account:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::OrHash
          ).void
        end
        attr_writer :ledger_account

        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        sig { returns(T.nilable(T::Hash[Symbol, String])) }
        attr_reader :metadata

        sig { params(metadata: T::Hash[Symbol, String]).void }
        attr_writer :metadata

        # A nickname for the external account. This is only for internal usage and won't
        # affect any payments
        sig { returns(T.nilable(String)) }
        attr_accessor :name

        # Required if receiving wire payments.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyAddress
            )
          )
        end
        attr_reader :party_address

        sig do
          params(
            party_address:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyAddress::OrHash
          ).void
        end
        attr_writer :party_address

        sig { returns(T.nilable(String)) }
        attr_reader :party_identifier

        sig { params(party_identifier: String).void }
        attr_writer :party_identifier

        # If this value isn't provided, it will be inherited from the counterparty's name.
        sig { returns(T.nilable(String)) }
        attr_reader :party_name

        sig { params(party_name: String).void }
        attr_writer :party_name

        # Either `individual` or `business`.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
            )
          )
        end
        attr_accessor :party_type

        # If you've enabled the Modern Treasury + Plaid integration in your Plaid account,
        # you can pass the processor token in this field.
        sig { returns(T.nilable(String)) }
        attr_reader :plaid_processor_token

        sig { params(plaid_processor_token: String).void }
        attr_writer :plaid_processor_token

        sig do
          returns(
            T.nilable(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail
              ]
            )
          )
        end
        attr_reader :routing_details

        sig do
          params(
            routing_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::OrHash
              ]
          ).void
        end
        attr_writer :routing_details

        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        sig do
          params(
            account_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::OrHash
              ],
            account_type: ModernTreasury::ExternalAccountType::OrSymbol,
            contact_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::OrHash
              ],
            ledger_account:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::OrHash,
            metadata: T::Hash[Symbol, String],
            name: T.nilable(String),
            party_address:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyAddress::OrHash,
            party_identifier: String,
            party_name: String,
            party_type:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
              ),
            plaid_processor_token: String,
            routing_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::OrHash
              ]
          ).returns(T.attached_class)
        end
        def self.new(
          account_details: nil,
          # Can be `checking`, `savings` or `other`.
          account_type: nil,
          contact_details: nil,
          # Specifies a ledger account object that will be created with the external
          # account. The resulting ledger account is linked to the external account for
          # auto-ledgering Payment objects. See
          # https://docs.moderntreasury.com/docs/linking-to-other-modern-treasury-objects
          # for more details.
          ledger_account: nil,
          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          metadata: nil,
          # A nickname for the external account. This is only for internal usage and won't
          # affect any payments
          name: nil,
          # Required if receiving wire payments.
          party_address: nil,
          party_identifier: nil,
          # If this value isn't provided, it will be inherited from the counterparty's name.
          party_name: nil,
          # Either `individual` or `business`.
          party_type: nil,
          # If you've enabled the Modern Treasury + Plaid integration in your Plaid account,
          # you can pass the processor token in this field.
          plaid_processor_token: nil,
          routing_details: nil
        )
        end

        sig do
          override.returns(
            {
              account_details:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail
                ],
              account_type: ModernTreasury::ExternalAccountType::OrSymbol,
              contact_details:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail
                ],
              ledger_account:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount,
              metadata: T::Hash[Symbol, String],
              name: T.nilable(String),
              party_address:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyAddress,
              party_identifier: String,
              party_name: String,
              party_type:
                T.nilable(
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
                ),
              plaid_processor_token: String,
              routing_details:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail
                ]
            }
          )
        end
        def to_hash
        end

        class AccountDetail < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail,
                ModernTreasury::Internal::AnyHash
              )
            end

          sig { returns(String) }
          attr_accessor :account_number

          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
              )
            )
          end
          attr_reader :account_number_type

          sig do
            params(
              account_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
            ).void
          end
          attr_writer :account_number_type

          sig do
            params(
              account_number: String,
              account_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
            ).returns(T.attached_class)
          end
          def self.new(account_number:, account_number_type: nil)
          end

          sig do
            override.returns(
              {
                account_number: String,
                account_number_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
              }
            )
          end
          def to_hash
          end

          module AccountNumberType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            AU_NUMBER =
              T.let(
                :au_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            BASE_ADDRESS =
              T.let(
                :base_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            CLABE =
              T.let(
                :clabe,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            ETHEREUM_ADDRESS =
              T.let(
                :ethereum_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            HK_NUMBER =
              T.let(
                :hk_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            IBAN =
              T.let(
                :iban,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            ID_NUMBER =
              T.let(
                :id_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            NZ_NUMBER =
              T.let(
                :nz_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            OTHER =
              T.let(
                :other,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            PAN =
              T.let(
                :pan,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            POLYGON_ADDRESS =
              T.let(
                :polygon_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            SG_NUMBER =
              T.let(
                :sg_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            SOLANA_ADDRESS =
              T.let(
                :solana_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            WALLET_ADDRESS =
              T.let(
                :wallet_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end

        class ContactDetail < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail,
                ModernTreasury::Internal::AnyHash
              )
            end

          sig { returns(T.nilable(String)) }
          attr_reader :contact_identifier

          sig { params(contact_identifier: String).void }
          attr_writer :contact_identifier

          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::OrSymbol
              )
            )
          end
          attr_reader :contact_identifier_type

          sig do
            params(
              contact_identifier_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::OrSymbol
            ).void
          end
          attr_writer :contact_identifier_type

          sig do
            params(
              contact_identifier: String,
              contact_identifier_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::OrSymbol
            ).returns(T.attached_class)
          end
          def self.new(contact_identifier: nil, contact_identifier_type: nil)
          end

          sig do
            override.returns(
              {
                contact_identifier: String,
                contact_identifier_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::OrSymbol
              }
            )
          end
          def to_hash
          end

          module ContactIdentifierType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            EMAIL =
              T.let(
                :email,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::TaggedSymbol
              )
            PHONE_NUMBER =
              T.let(
                :phone_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::TaggedSymbol
              )
            WEBSITE =
              T.let(
                :website,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::ContactDetail::ContactIdentifierType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end

        class LedgerAccount < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount,
                ModernTreasury::Internal::AnyHash
              )
            end

          # The currency of the ledger account.
          sig { returns(String) }
          attr_accessor :currency

          # The id of the ledger that this account belongs to.
          sig { returns(String) }
          attr_accessor :ledger_id

          # The name of the ledger account.
          sig { returns(String) }
          attr_accessor :name

          # The normal balance of the ledger account.
          sig { returns(ModernTreasury::TransactionDirection::OrSymbol) }
          attr_accessor :normal_balance

          # The currency exponent of the ledger account.
          sig { returns(T.nilable(Integer)) }
          attr_accessor :currency_exponent

          # The description of the ledger account.
          sig { returns(T.nilable(String)) }
          attr_accessor :description

          # The array of ledger account category ids that this ledger account should be a
          # child of.
          sig { returns(T.nilable(T::Array[String])) }
          attr_reader :ledger_account_category_ids

          sig { params(ledger_account_category_ids: T::Array[String]).void }
          attr_writer :ledger_account_category_ids

          # If the ledger account links to another object in Modern Treasury, the id will be
          # populated here, otherwise null.
          sig { returns(T.nilable(String)) }
          attr_reader :ledgerable_id

          sig { params(ledgerable_id: String).void }
          attr_writer :ledgerable_id

          # If the ledger account links to another object in Modern Treasury, the type will
          # be populated here, otherwise null. The value is one of internal_account or
          # external_account.
          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::OrSymbol
              )
            )
          end
          attr_reader :ledgerable_type

          sig do
            params(
              ledgerable_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::OrSymbol
            ).void
          end
          attr_writer :ledgerable_type

          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          sig { returns(T.nilable(T::Hash[Symbol, String])) }
          attr_reader :metadata

          sig { params(metadata: T::Hash[Symbol, String]).void }
          attr_writer :metadata

          # Specifies a ledger account object that will be created with the external
          # account. The resulting ledger account is linked to the external account for
          # auto-ledgering Payment objects. See
          # https://docs.moderntreasury.com/docs/linking-to-other-modern-treasury-objects
          # for more details.
          sig do
            params(
              currency: String,
              ledger_id: String,
              name: String,
              normal_balance: ModernTreasury::TransactionDirection::OrSymbol,
              currency_exponent: T.nilable(Integer),
              description: T.nilable(String),
              ledger_account_category_ids: T::Array[String],
              ledgerable_id: String,
              ledgerable_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::OrSymbol,
              metadata: T::Hash[Symbol, String]
            ).returns(T.attached_class)
          end
          def self.new(
            # The currency of the ledger account.
            currency:,
            # The id of the ledger that this account belongs to.
            ledger_id:,
            # The name of the ledger account.
            name:,
            # The normal balance of the ledger account.
            normal_balance:,
            # The currency exponent of the ledger account.
            currency_exponent: nil,
            # The description of the ledger account.
            description: nil,
            # The array of ledger account category ids that this ledger account should be a
            # child of.
            ledger_account_category_ids: nil,
            # If the ledger account links to another object in Modern Treasury, the id will be
            # populated here, otherwise null.
            ledgerable_id: nil,
            # If the ledger account links to another object in Modern Treasury, the type will
            # be populated here, otherwise null. The value is one of internal_account or
            # external_account.
            ledgerable_type: nil,
            # Additional data represented as key-value pairs. Both the key and value must be
            # strings.
            metadata: nil
          )
          end

          sig do
            override.returns(
              {
                currency: String,
                ledger_id: String,
                name: String,
                normal_balance: ModernTreasury::TransactionDirection::OrSymbol,
                currency_exponent: T.nilable(Integer),
                description: T.nilable(String),
                ledger_account_category_ids: T::Array[String],
                ledgerable_id: String,
                ledgerable_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::OrSymbol,
                metadata: T::Hash[Symbol, String]
              }
            )
          end
          def to_hash
          end

          # If the ledger account links to another object in Modern Treasury, the type will
          # be populated here, otherwise null. The value is one of internal_account or
          # external_account.
          module LedgerableType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            COUNTERPARTY =
              T.let(
                :counterparty,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::TaggedSymbol
              )
            EXTERNAL_ACCOUNT =
              T.let(
                :external_account,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::TaggedSymbol
              )
            INTERNAL_ACCOUNT =
              T.let(
                :internal_account,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::TaggedSymbol
              )
            VIRTUAL_ACCOUNT =
              T.let(
                :virtual_account,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::LedgerAccount::LedgerableType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end

        class PartyAddress < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyAddress,
                ModernTreasury::Internal::AnyHash
              )
            end

          # Country code conforms to [ISO 3166-1 alpha-2]
          sig { returns(T.nilable(String)) }
          attr_accessor :country

          sig { returns(T.nilable(String)) }
          attr_accessor :line1

          sig { returns(T.nilable(String)) }
          attr_accessor :line2

          # Locality or City.
          sig { returns(T.nilable(String)) }
          attr_accessor :locality

          # The postal code of the address.
          sig { returns(T.nilable(String)) }
          attr_accessor :postal_code

          # Region or State.
          sig { returns(T.nilable(String)) }
          attr_accessor :region

          # Required if receiving wire payments.
          sig do
            params(
              country: T.nilable(String),
              line1: T.nilable(String),
              line2: T.nilable(String),
              locality: T.nilable(String),
              postal_code: T.nilable(String),
              region: T.nilable(String)
            ).returns(T.attached_class)
          end
          def self.new(
            # Country code conforms to [ISO 3166-1 alpha-2]
            country: nil,
            line1: nil,
            line2: nil,
            # Locality or City.
            locality: nil,
            # The postal code of the address.
            postal_code: nil,
            # Region or State.
            region: nil
          )
          end

          sig do
            override.returns(
              {
                country: T.nilable(String),
                line1: T.nilable(String),
                line2: T.nilable(String),
                locality: T.nilable(String),
                postal_code: T.nilable(String),
                region: T.nilable(String)
              }
            )
          end
          def to_hash
          end
        end

        # Either `individual` or `business`.
        module PartyType
          extend ModernTreasury::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias do
              T.all(
                Symbol,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType
              )
            end
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          BUSINESS =
            T.let(
              :business,
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
            )
          INDIVIDUAL =
            T.let(
              :individual,
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
            )

          sig do
            override.returns(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
              ]
            )
          end
          def self.values
          end
        end

        class RoutingDetail < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail,
                ModernTreasury::Internal::AnyHash
              )
            end

          sig { returns(String) }
          attr_accessor :routing_number

          sig do
            returns(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol
            )
          end
          attr_accessor :routing_number_type

          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
              )
            )
          end
          attr_reader :payment_type

          sig do
            params(
              payment_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
            ).void
          end
          attr_writer :payment_type

          sig do
            params(
              routing_number: String,
              routing_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol,
              payment_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
            ).returns(T.attached_class)
          end
          def self.new(routing_number:, routing_number_type:, payment_type: nil)
          end

          sig do
            override.returns(
              {
                routing_number: String,
                routing_number_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol,
                payment_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
              }
            )
          end
          def to_hash
          end

          module RoutingNumberType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            ABA =
              T.let(
                :aba,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            AU_BSB =
              T.let(
                :au_bsb,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            BR_CODIGO =
              T.let(
                :br_codigo,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CA_CPA =
              T.let(
                :ca_cpa,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CHIPS =
              T.let(
                :chips,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CNAPS =
              T.let(
                :cnaps,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            DK_INTERBANK_CLEARING_CODE =
              T.let(
                :dk_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            GB_SORT_CODE =
              T.let(
                :gb_sort_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            HK_INTERBANK_CLEARING_CODE =
              T.let(
                :hk_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            HU_INTERBANK_CLEARING_CODE =
              T.let(
                :hu_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            ID_SKNBI_CODE =
              T.let(
                :id_sknbi_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            IL_BANK_CODE =
              T.let(
                :il_bank_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            IN_IFSC =
              T.let(
                :in_ifsc,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            JP_ZENGIN_CODE =
              T.let(
                :jp_zengin_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            MY_BRANCH_CODE =
              T.let(
                :my_branch_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            MX_BANK_IDENTIFIER =
              T.let(
                :mx_bank_identifier,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            NZ_NATIONAL_CLEARING_CODE =
              T.let(
                :nz_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            PL_NATIONAL_CLEARING_CODE =
              T.let(
                :pl_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SE_BANKGIRO_CLEARING_CODE =
              T.let(
                :se_bankgiro_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SG_INTERBANK_CLEARING_CODE =
              T.let(
                :sg_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SWIFT =
              T.let(
                :swift,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            ZA_NATIONAL_CLEARING_CODE =
              T.let(
                :za_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end

          module PaymentType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            ACH =
              T.let(
                :ach,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            AU_BECS =
              T.let(
                :au_becs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BACS =
              T.let(
                :bacs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BASE =
              T.let(
                :base,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BOOK =
              T.let(
                :book,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CARD =
              T.let(
                :card,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CHATS =
              T.let(
                :chats,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CHECK =
              T.let(
                :check,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CROSS_BORDER =
              T.let(
                :cross_border,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            DK_NETS =
              T.let(
                :dk_nets,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            EFT =
              T.let(
                :eft,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            ETHEREUM =
              T.let(
                :ethereum,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            HU_ICS =
              T.let(
                :hu_ics,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            INTERAC =
              T.let(
                :interac,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            MASAV =
              T.let(
                :masav,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            MX_CCEN =
              T.let(
                :mx_ccen,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NEFT =
              T.let(
                :neft,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NICS =
              T.let(
                :nics,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NZ_BECS =
              T.let(
                :nz_becs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            PL_ELIXIR =
              T.let(
                :pl_elixir,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            POLYGON =
              T.let(
                :polygon,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            PROVXCHANGE =
              T.let(
                :provxchange,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            RO_SENT =
              T.let(
                :ro_sent,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            RTP =
              T.let(
                :rtp,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SE_BANKGIROT =
              T.let(
                :se_bankgirot,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SEN =
              T.let(
                :sen,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SEPA =
              T.let(
                :sepa,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SG_GIRO =
              T.let(
                :sg_giro,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SIC =
              T.let(
                :sic,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SIGNET =
              T.let(
                :signet,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SKNBI =
              T.let(
                :sknbi,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SOLANA =
              T.let(
                :solana,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            WIRE =
              T.let(
                :wire,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            ZENGIN =
              T.let(
                :zengin,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end
      end
    end
  end
end
