# typed: strong

module ModernTreasury
  module Models
    class PaymentOrderCreateAsyncParams < ModernTreasury::Internal::Type::BaseModel
      extend ModernTreasury::Internal::Type::RequestParameters::Converter
      include ModernTreasury::Internal::Type::RequestParameters

      OrHash =
        T.type_alias do
          T.any(
            ModernTreasury::PaymentOrderCreateAsyncParams,
            ModernTreasury::Internal::AnyHash
          )
        end

      # Value in specified currency's smallest unit. e.g. $10 would be represented as
      # 1000 (cents). For RTP, the maximum amount allowed by the network is $100,000.
      sig { returns(Integer) }
      attr_accessor :amount

      # One of `credit`, `debit`. Describes the direction money is flowing in the
      # transaction. A `credit` moves money from your account to someone else's. A
      # `debit` pulls money from someone else's account to your own. Note that wire,
      # rtp, and check payments will always be `credit`.
      sig do
        returns(
          ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol
        )
      end
      attr_accessor :direction

      # The ID of one of your organization's internal accounts.
      sig { returns(String) }
      attr_accessor :originating_account_id

      # One of `ach`, `se_bankgirot`, `eft`, `wire`, `check`, `sen`, `book`, `rtp`,
      # `sepa`, `bacs`, `au_becs`, `interac`, `neft`, `nics`,
      # `nz_national_clearing_code`, `sic`, `signet`, `provexchange`, `zengin`.
      sig { returns(ModernTreasury::PaymentOrderType::OrSymbol) }
      attr_accessor :type

      sig do
        returns(
          T.nilable(ModernTreasury::PaymentOrderCreateAsyncParams::Accounting)
        )
      end
      attr_reader :accounting

      sig do
        params(
          accounting:
            ModernTreasury::PaymentOrderCreateAsyncParams::Accounting::OrHash
        ).void
      end
      attr_writer :accounting

      # The ID of one of your accounting categories. Note that these will only be
      # accessible if your accounting system has been connected.
      sig { returns(T.nilable(String)) }
      attr_accessor :accounting_category_id

      # The ID of one of your accounting ledger classes. Note that these will only be
      # accessible if your accounting system has been connected.
      sig { returns(T.nilable(String)) }
      attr_accessor :accounting_ledger_class_id

      # The party that will pay the fees for the payment order. See
      # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
      # differences between the options.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
          )
        )
      end
      attr_accessor :charge_bearer

      # Defaults to the currency of the originating account.
      sig { returns(T.nilable(ModernTreasury::Currency::OrSymbol)) }
      attr_reader :currency

      sig { params(currency: ModernTreasury::Currency::OrSymbol).void }
      attr_writer :currency

      # An optional description for internal use.
      sig { returns(T.nilable(String)) }
      attr_accessor :description

      # Date transactions are to be posted to the participants' account. Defaults to the
      # current business day or the next business day if the current day is a bank
      # holiday or weekend. Format: yyyy-mm-dd.
      sig { returns(T.nilable(Date)) }
      attr_reader :effective_date

      sig { params(effective_date: Date).void }
      attr_writer :effective_date

      # RFP payments require an expires_at. This value must be past the effective_date.
      sig { returns(T.nilable(Time)) }
      attr_accessor :expires_at

      # A payment type to fallback to if the original type is not valid for the
      # receiving account. Currently, this only supports falling back from RTP to ACH
      # (type=rtp and fallback_type=ach)
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol
          )
        )
      end
      attr_reader :fallback_type

      sig do
        params(
          fallback_type:
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol
        ).void
      end
      attr_writer :fallback_type

      # If present, indicates a specific foreign exchange contract number that has been
      # generated by your financial institution.
      sig { returns(T.nilable(String)) }
      attr_accessor :foreign_exchange_contract

      # Indicates the type of FX transfer to initiate, can be either
      # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
      # currency matches the originating account currency.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
          )
        )
      end
      attr_accessor :foreign_exchange_indicator

      # Specifies a ledger transaction object that will be created with the payment
      # order. If the ledger transaction cannot be created, then the payment order
      # creation will fail. The resulting ledger transaction will mirror the status of
      # the payment order.
      sig { returns(T.nilable(ModernTreasury::LedgerTransactionCreateRequest)) }
      attr_reader :ledger_transaction

      sig do
        params(
          ledger_transaction:
            ModernTreasury::LedgerTransactionCreateRequest::OrHash
        ).void
      end
      attr_writer :ledger_transaction

      # Either ledger_transaction or ledger_transaction_id can be provided. Only a
      # pending ledger transaction can be attached upon payment order creation. Once the
      # payment order is created, the status of the ledger transaction tracks the
      # payment order automatically.
      sig { returns(T.nilable(String)) }
      attr_reader :ledger_transaction_id

      sig { params(ledger_transaction_id: String).void }
      attr_writer :ledger_transaction_id

      # An array of line items that must sum up to the amount of the payment order.
      sig do
        returns(
          T.nilable(
            T::Array[ModernTreasury::PaymentOrderCreateAsyncParams::LineItem]
          )
        )
      end
      attr_reader :line_items

      sig do
        params(
          line_items:
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem::OrHash
            ]
        ).void
      end
      attr_writer :line_items

      # Additional data represented as key-value pairs. Both the key and value must be
      # strings.
      sig { returns(T.nilable(T::Hash[Symbol, String])) }
      attr_reader :metadata

      sig { params(metadata: T::Hash[Symbol, String]).void }
      attr_writer :metadata

      # A boolean to determine if NSF Protection is enabled for this payment order. Note
      # that this setting must also be turned on in your organization settings page.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :nsf_protected

      sig { params(nsf_protected: T::Boolean).void }
      attr_writer :nsf_protected

      # If present, this will replace your default company name on receiver's bank
      # statement. This field can only be used for ACH payments currently. For ACH, only
      # the first 16 characters of this string will be used. Any additional characters
      # will be truncated.
      sig { returns(T.nilable(String)) }
      attr_accessor :originating_party_name

      # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
      # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
      # an overnight check rather than standard mail.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol
          )
        )
      end
      attr_reader :priority

      sig do
        params(
          priority:
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol
        ).void
      end
      attr_writer :priority

      # If present, Modern Treasury will not process the payment until after this time.
      # If `process_after` is past the cutoff for `effective_date`, `process_after` will
      # take precedence and `effective_date` will automatically update to reflect the
      # earliest possible sending date after `process_after`. Format is ISO8601
      # timestamp.
      sig { returns(T.nilable(Time)) }
      attr_accessor :process_after

      # For `wire`, this is usually the purpose which is transmitted via the
      # "InstrForDbtrAgt" field in the ISO20022 file. For `eft`, this field is the 3
      # digit CPA Code that will be attached to the payment.
      sig { returns(T.nilable(String)) }
      attr_accessor :purpose

      # Either `receiving_account` or `receiving_account_id` must be present. When using
      # `receiving_account_id`, you may pass the id of an external account or an
      # internal account.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount
          )
        )
      end
      attr_reader :receiving_account

      sig do
        params(
          receiving_account:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::OrHash
        ).void
      end
      attr_writer :receiving_account

      # Either `receiving_account` or `receiving_account_id` must be present. When using
      # `receiving_account_id`, you may pass the id of an external account or an
      # internal account.
      sig { returns(T.nilable(String)) }
      attr_reader :receiving_account_id

      sig { params(receiving_account_id: String).void }
      attr_writer :receiving_account_id

      # One of `unreconciled`, `tentatively_reconciled` or `reconciled`.
      sig do
        returns(
          T.nilable(
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::OrSymbol
          )
        )
      end
      attr_reader :reconciliation_status

      sig do
        params(
          reconciliation_status:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::OrSymbol
        ).void
      end
      attr_writer :reconciliation_status

      # For `ach`, this field will be passed through on an addenda record. For `wire`
      # payments the field will be passed through as the "Originator to Beneficiary
      # Information", also known as OBI or Fedwire tag 6000.
      sig { returns(T.nilable(String)) }
      attr_accessor :remittance_information

      # Send an email to the counterparty when the payment order is sent to the bank. If
      # `null`, `send_remittance_advice` on the Counterparty is used.
      sig { returns(T.nilable(T::Boolean)) }
      attr_accessor :send_remittance_advice

      # An optional descriptor which will appear in the receiver's statement. For
      # `check` payments this field will be used as the memo line. For `ach` the maximum
      # length is 10 characters. Note that for ACH payments, the name on your bank
      # account will be included automatically by the bank, so you can use the
      # characters for other useful information. For `eft` the maximum length is 15
      # characters.
      sig { returns(T.nilable(String)) }
      attr_accessor :statement_descriptor

      # An additional layer of classification for the type of payment order you are
      # doing. This field is only used for `ach` payment orders currently. For `ach`
      # payment orders, the `subtype` represents the SEC code. We currently support
      # `CCD`, `PPD`, `IAT`, `CTX`, `WEB`, `CIE`, and `TEL`.
      sig { returns(T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol)) }
      attr_accessor :subtype

      # A flag that determines whether a payment order should go through transaction
      # monitoring.
      sig { returns(T.nilable(T::Boolean)) }
      attr_reader :transaction_monitoring_enabled

      sig { params(transaction_monitoring_enabled: T::Boolean).void }
      attr_writer :transaction_monitoring_enabled

      # Identifier of the ultimate originator of the payment order.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_originating_party_identifier

      # Name of the ultimate originator of the payment order.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_originating_party_name

      # Identifier of the ultimate funds recipient.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_receiving_party_identifier

      # Name of the ultimate funds recipient.
      sig { returns(T.nilable(String)) }
      attr_accessor :ultimate_receiving_party_name

      sig do
        params(
          amount: Integer,
          direction:
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol,
          originating_account_id: String,
          type: ModernTreasury::PaymentOrderType::OrSymbol,
          accounting:
            ModernTreasury::PaymentOrderCreateAsyncParams::Accounting::OrHash,
          accounting_category_id: T.nilable(String),
          accounting_ledger_class_id: T.nilable(String),
          charge_bearer:
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
            ),
          currency: ModernTreasury::Currency::OrSymbol,
          description: T.nilable(String),
          effective_date: Date,
          expires_at: T.nilable(Time),
          fallback_type:
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol,
          foreign_exchange_contract: T.nilable(String),
          foreign_exchange_indicator:
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
            ),
          ledger_transaction:
            ModernTreasury::LedgerTransactionCreateRequest::OrHash,
          ledger_transaction_id: String,
          line_items:
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem::OrHash
            ],
          metadata: T::Hash[Symbol, String],
          nsf_protected: T::Boolean,
          originating_party_name: T.nilable(String),
          priority:
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol,
          process_after: T.nilable(Time),
          purpose: T.nilable(String),
          receiving_account:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::OrHash,
          receiving_account_id: String,
          reconciliation_status:
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::OrSymbol,
          remittance_information: T.nilable(String),
          send_remittance_advice: T.nilable(T::Boolean),
          statement_descriptor: T.nilable(String),
          subtype: T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol),
          transaction_monitoring_enabled: T::Boolean,
          ultimate_originating_party_identifier: T.nilable(String),
          ultimate_originating_party_name: T.nilable(String),
          ultimate_receiving_party_identifier: T.nilable(String),
          ultimate_receiving_party_name: T.nilable(String),
          request_options: ModernTreasury::RequestOptions::OrHash
        ).returns(T.attached_class)
      end
      def self.new(
        # Value in specified currency's smallest unit. e.g. $10 would be represented as
        # 1000 (cents). For RTP, the maximum amount allowed by the network is $100,000.
        amount:,
        # One of `credit`, `debit`. Describes the direction money is flowing in the
        # transaction. A `credit` moves money from your account to someone else's. A
        # `debit` pulls money from someone else's account to your own. Note that wire,
        # rtp, and check payments will always be `credit`.
        direction:,
        # The ID of one of your organization's internal accounts.
        originating_account_id:,
        # One of `ach`, `se_bankgirot`, `eft`, `wire`, `check`, `sen`, `book`, `rtp`,
        # `sepa`, `bacs`, `au_becs`, `interac`, `neft`, `nics`,
        # `nz_national_clearing_code`, `sic`, `signet`, `provexchange`, `zengin`.
        type:,
        accounting: nil,
        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        accounting_category_id: nil,
        # The ID of one of your accounting ledger classes. Note that these will only be
        # accessible if your accounting system has been connected.
        accounting_ledger_class_id: nil,
        # The party that will pay the fees for the payment order. See
        # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
        # differences between the options.
        charge_bearer: nil,
        # Defaults to the currency of the originating account.
        currency: nil,
        # An optional description for internal use.
        description: nil,
        # Date transactions are to be posted to the participants' account. Defaults to the
        # current business day or the next business day if the current day is a bank
        # holiday or weekend. Format: yyyy-mm-dd.
        effective_date: nil,
        # RFP payments require an expires_at. This value must be past the effective_date.
        expires_at: nil,
        # A payment type to fallback to if the original type is not valid for the
        # receiving account. Currently, this only supports falling back from RTP to ACH
        # (type=rtp and fallback_type=ach)
        fallback_type: nil,
        # If present, indicates a specific foreign exchange contract number that has been
        # generated by your financial institution.
        foreign_exchange_contract: nil,
        # Indicates the type of FX transfer to initiate, can be either
        # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
        # currency matches the originating account currency.
        foreign_exchange_indicator: nil,
        # Specifies a ledger transaction object that will be created with the payment
        # order. If the ledger transaction cannot be created, then the payment order
        # creation will fail. The resulting ledger transaction will mirror the status of
        # the payment order.
        ledger_transaction: nil,
        # Either ledger_transaction or ledger_transaction_id can be provided. Only a
        # pending ledger transaction can be attached upon payment order creation. Once the
        # payment order is created, the status of the ledger transaction tracks the
        # payment order automatically.
        ledger_transaction_id: nil,
        # An array of line items that must sum up to the amount of the payment order.
        line_items: nil,
        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        metadata: nil,
        # A boolean to determine if NSF Protection is enabled for this payment order. Note
        # that this setting must also be turned on in your organization settings page.
        nsf_protected: nil,
        # If present, this will replace your default company name on receiver's bank
        # statement. This field can only be used for ACH payments currently. For ACH, only
        # the first 16 characters of this string will be used. Any additional characters
        # will be truncated.
        originating_party_name: nil,
        # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
        # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
        # an overnight check rather than standard mail.
        priority: nil,
        # If present, Modern Treasury will not process the payment until after this time.
        # If `process_after` is past the cutoff for `effective_date`, `process_after` will
        # take precedence and `effective_date` will automatically update to reflect the
        # earliest possible sending date after `process_after`. Format is ISO8601
        # timestamp.
        process_after: nil,
        # For `wire`, this is usually the purpose which is transmitted via the
        # "InstrForDbtrAgt" field in the ISO20022 file. For `eft`, this field is the 3
        # digit CPA Code that will be attached to the payment.
        purpose: nil,
        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        receiving_account: nil,
        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        receiving_account_id: nil,
        # One of `unreconciled`, `tentatively_reconciled` or `reconciled`.
        reconciliation_status: nil,
        # For `ach`, this field will be passed through on an addenda record. For `wire`
        # payments the field will be passed through as the "Originator to Beneficiary
        # Information", also known as OBI or Fedwire tag 6000.
        remittance_information: nil,
        # Send an email to the counterparty when the payment order is sent to the bank. If
        # `null`, `send_remittance_advice` on the Counterparty is used.
        send_remittance_advice: nil,
        # An optional descriptor which will appear in the receiver's statement. For
        # `check` payments this field will be used as the memo line. For `ach` the maximum
        # length is 10 characters. Note that for ACH payments, the name on your bank
        # account will be included automatically by the bank, so you can use the
        # characters for other useful information. For `eft` the maximum length is 15
        # characters.
        statement_descriptor: nil,
        # An additional layer of classification for the type of payment order you are
        # doing. This field is only used for `ach` payment orders currently. For `ach`
        # payment orders, the `subtype` represents the SEC code. We currently support
        # `CCD`, `PPD`, `IAT`, `CTX`, `WEB`, `CIE`, and `TEL`.
        subtype: nil,
        # A flag that determines whether a payment order should go through transaction
        # monitoring.
        transaction_monitoring_enabled: nil,
        # Identifier of the ultimate originator of the payment order.
        ultimate_originating_party_identifier: nil,
        # Name of the ultimate originator of the payment order.
        ultimate_originating_party_name: nil,
        # Identifier of the ultimate funds recipient.
        ultimate_receiving_party_identifier: nil,
        # Name of the ultimate funds recipient.
        ultimate_receiving_party_name: nil,
        request_options: {}
      )
      end

      sig do
        override.returns(
          {
            amount: Integer,
            direction:
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction::OrSymbol,
            originating_account_id: String,
            type: ModernTreasury::PaymentOrderType::OrSymbol,
            accounting:
              ModernTreasury::PaymentOrderCreateAsyncParams::Accounting,
            accounting_category_id: T.nilable(String),
            accounting_ledger_class_id: T.nilable(String),
            charge_bearer:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::OrSymbol
              ),
            currency: ModernTreasury::Currency::OrSymbol,
            description: T.nilable(String),
            effective_date: Date,
            expires_at: T.nilable(Time),
            fallback_type:
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::OrSymbol,
            foreign_exchange_contract: T.nilable(String),
            foreign_exchange_indicator:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::OrSymbol
              ),
            ledger_transaction: ModernTreasury::LedgerTransactionCreateRequest,
            ledger_transaction_id: String,
            line_items:
              T::Array[ModernTreasury::PaymentOrderCreateAsyncParams::LineItem],
            metadata: T::Hash[Symbol, String],
            nsf_protected: T::Boolean,
            originating_party_name: T.nilable(String),
            priority:
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority::OrSymbol,
            process_after: T.nilable(Time),
            purpose: T.nilable(String),
            receiving_account:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount,
            receiving_account_id: String,
            reconciliation_status:
              ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::OrSymbol,
            remittance_information: T.nilable(String),
            send_remittance_advice: T.nilable(T::Boolean),
            statement_descriptor: T.nilable(String),
            subtype: T.nilable(ModernTreasury::PaymentOrderSubtype::OrSymbol),
            transaction_monitoring_enabled: T::Boolean,
            ultimate_originating_party_identifier: T.nilable(String),
            ultimate_originating_party_name: T.nilable(String),
            ultimate_receiving_party_identifier: T.nilable(String),
            ultimate_receiving_party_name: T.nilable(String),
            request_options: ModernTreasury::RequestOptions
          }
        )
      end
      def to_hash
      end

      # One of `credit`, `debit`. Describes the direction money is flowing in the
      # transaction. A `credit` moves money from your account to someone else's. A
      # `debit` pulls money from someone else's account to your own. Note that wire,
      # rtp, and check payments will always be `credit`.
      module Direction
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        CREDIT =
          T.let(
            :credit,
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
          )
        DEBIT =
          T.let(
            :debit,
            ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::Direction::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class Accounting < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::Accounting,
              ModernTreasury::Internal::AnyHash
            )
          end

        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :account_id

        # The ID of one of the class objects in your accounting system. Class objects
        # track segments of your business independent of client or project. Note that
        # these will only be accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :class_id

        sig do
          params(
            account_id: T.nilable(String),
            class_id: T.nilable(String)
          ).returns(T.attached_class)
        end
        def self.new(
          # The ID of one of your accounting categories. Note that these will only be
          # accessible if your accounting system has been connected.
          account_id: nil,
          # The ID of one of the class objects in your accounting system. Class objects
          # track segments of your business independent of client or project. Note that
          # these will only be accessible if your accounting system has been connected.
          class_id: nil
        )
        end

        sig do
          override.returns(
            { account_id: T.nilable(String), class_id: T.nilable(String) }
          )
        end
        def to_hash
        end
      end

      # The party that will pay the fees for the payment order. See
      # https://docs.moderntreasury.com/payments/docs/charge-bearer to understand the
      # differences between the options.
      module ChargeBearer
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        SHARED =
          T.let(
            :shared,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )
        SENDER =
          T.let(
            :sender,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )
        RECEIVER =
          T.let(
            :receiver,
            ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::ChargeBearer::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      # A payment type to fallback to if the original type is not valid for the
      # receiving account. Currently, this only supports falling back from RTP to ACH
      # (type=rtp and fallback_type=ach)
      module FallbackType
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        ACH =
          T.let(
            :ach,
            ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::FallbackType::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      # Indicates the type of FX transfer to initiate, can be either
      # `variable_to_fixed`, `fixed_to_variable`, or `null` if the payment order
      # currency matches the originating account currency.
      module ForeignExchangeIndicator
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        FIXED_TO_VARIABLE =
          T.let(
            :fixed_to_variable,
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
          )
        VARIABLE_TO_FIXED =
          T.let(
            :variable_to_fixed,
            ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::ForeignExchangeIndicator::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class LineItem < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::LineItem,
              ModernTreasury::Internal::AnyHash
            )
          end

        # Value in specified currency's smallest unit. e.g. $10 would be represented
        # as 1000.
        sig { returns(Integer) }
        attr_accessor :amount

        # The ID of one of your accounting categories. Note that these will only be
        # accessible if your accounting system has been connected.
        sig { returns(T.nilable(String)) }
        attr_accessor :accounting_category_id

        # A free-form description of the line item.
        sig { returns(T.nilable(String)) }
        attr_accessor :description

        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        sig { returns(T.nilable(T::Hash[Symbol, String])) }
        attr_reader :metadata

        sig { params(metadata: T::Hash[Symbol, String]).void }
        attr_writer :metadata

        sig do
          params(
            amount: Integer,
            accounting_category_id: T.nilable(String),
            description: T.nilable(String),
            metadata: T::Hash[Symbol, String]
          ).returns(T.attached_class)
        end
        def self.new(
          # Value in specified currency's smallest unit. e.g. $10 would be represented
          # as 1000.
          amount:,
          # The ID of one of your accounting categories. Note that these will only be
          # accessible if your accounting system has been connected.
          accounting_category_id: nil,
          # A free-form description of the line item.
          description: nil,
          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          metadata: nil
        )
        end

        sig do
          override.returns(
            {
              amount: Integer,
              accounting_category_id: T.nilable(String),
              description: T.nilable(String),
              metadata: T::Hash[Symbol, String]
            }
          )
        end
        def to_hash
        end
      end

      # Either `normal` or `high`. For ACH and EFT payments, `high` represents a
      # same-day ACH or EFT transfer, respectively. For check payments, `high` can mean
      # an overnight check rather than standard mail.
      module Priority
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        HIGH =
          T.let(
            :high,
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
          )
        NORMAL =
          T.let(
            :normal,
            ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::Priority::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end

      class ReceivingAccount < ModernTreasury::Internal::Type::BaseModel
        OrHash =
          T.type_alias do
            T.any(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount,
              ModernTreasury::Internal::AnyHash
            )
          end

        sig do
          returns(
            T.nilable(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail
              ]
            )
          )
        end
        attr_reader :account_details

        sig do
          params(
            account_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::OrHash
              ]
          ).void
        end
        attr_writer :account_details

        # Can be `checking`, `savings` or `other`.
        sig do
          returns(T.nilable(ModernTreasury::ExternalAccountType::OrSymbol))
        end
        attr_reader :account_type

        sig do
          params(
            account_type: ModernTreasury::ExternalAccountType::OrSymbol
          ).void
        end
        attr_writer :account_type

        sig do
          returns(
            T.nilable(T::Array[ModernTreasury::ContactDetailCreateRequest])
          )
        end
        attr_reader :contact_details

        sig do
          params(
            contact_details:
              T::Array[ModernTreasury::ContactDetailCreateRequest::OrHash]
          ).void
        end
        attr_writer :contact_details

        # An optional user-defined 180 character unique identifier.
        sig { returns(T.nilable(String)) }
        attr_accessor :external_id

        # Specifies a ledger account object that will be created with the external
        # account. The resulting ledger account is linked to the external account for
        # auto-ledgering Payment objects. See
        # https://docs.moderntreasury.com/docs/linking-to-other-modern-treasury-objects
        # for more details.
        sig { returns(T.nilable(ModernTreasury::LedgerAccountCreateRequest)) }
        attr_reader :ledger_account

        sig do
          params(
            ledger_account: ModernTreasury::LedgerAccountCreateRequest::OrHash
          ).void
        end
        attr_writer :ledger_account

        # Additional data represented as key-value pairs. Both the key and value must be
        # strings.
        sig { returns(T.nilable(T::Hash[Symbol, String])) }
        attr_reader :metadata

        sig { params(metadata: T::Hash[Symbol, String]).void }
        attr_writer :metadata

        # A nickname for the external account. This is only for internal usage and won't
        # affect any payments
        sig { returns(T.nilable(String)) }
        attr_accessor :name

        # Required if receiving wire payments.
        sig { returns(T.nilable(ModernTreasury::AddressRequest)) }
        attr_reader :party_address

        sig do
          params(party_address: ModernTreasury::AddressRequest::OrHash).void
        end
        attr_writer :party_address

        sig { returns(T.nilable(String)) }
        attr_reader :party_identifier

        sig { params(party_identifier: String).void }
        attr_writer :party_identifier

        # If this value isn't provided, it will be inherited from the counterparty's name.
        sig { returns(T.nilable(String)) }
        attr_reader :party_name

        sig { params(party_name: String).void }
        attr_writer :party_name

        # Either `individual` or `business`.
        sig do
          returns(
            T.nilable(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
            )
          )
        end
        attr_accessor :party_type

        # If you've enabled the Modern Treasury + Plaid integration in your Plaid account,
        # you can pass the processor token in this field.
        sig { returns(T.nilable(String)) }
        attr_reader :plaid_processor_token

        sig { params(plaid_processor_token: String).void }
        attr_writer :plaid_processor_token

        sig do
          returns(
            T.nilable(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail
              ]
            )
          )
        end
        attr_reader :routing_details

        sig do
          params(
            routing_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::OrHash
              ]
          ).void
        end
        attr_writer :routing_details

        # Either `receiving_account` or `receiving_account_id` must be present. When using
        # `receiving_account_id`, you may pass the id of an external account or an
        # internal account.
        sig do
          params(
            account_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::OrHash
              ],
            account_type: ModernTreasury::ExternalAccountType::OrSymbol,
            contact_details:
              T::Array[ModernTreasury::ContactDetailCreateRequest::OrHash],
            external_id: T.nilable(String),
            ledger_account: ModernTreasury::LedgerAccountCreateRequest::OrHash,
            metadata: T::Hash[Symbol, String],
            name: T.nilable(String),
            party_address: ModernTreasury::AddressRequest::OrHash,
            party_identifier: String,
            party_name: String,
            party_type:
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
              ),
            plaid_processor_token: String,
            routing_details:
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::OrHash
              ]
          ).returns(T.attached_class)
        end
        def self.new(
          account_details: nil,
          # Can be `checking`, `savings` or `other`.
          account_type: nil,
          contact_details: nil,
          # An optional user-defined 180 character unique identifier.
          external_id: nil,
          # Specifies a ledger account object that will be created with the external
          # account. The resulting ledger account is linked to the external account for
          # auto-ledgering Payment objects. See
          # https://docs.moderntreasury.com/docs/linking-to-other-modern-treasury-objects
          # for more details.
          ledger_account: nil,
          # Additional data represented as key-value pairs. Both the key and value must be
          # strings.
          metadata: nil,
          # A nickname for the external account. This is only for internal usage and won't
          # affect any payments
          name: nil,
          # Required if receiving wire payments.
          party_address: nil,
          party_identifier: nil,
          # If this value isn't provided, it will be inherited from the counterparty's name.
          party_name: nil,
          # Either `individual` or `business`.
          party_type: nil,
          # If you've enabled the Modern Treasury + Plaid integration in your Plaid account,
          # you can pass the processor token in this field.
          plaid_processor_token: nil,
          routing_details: nil
        )
        end

        sig do
          override.returns(
            {
              account_details:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail
                ],
              account_type: ModernTreasury::ExternalAccountType::OrSymbol,
              contact_details:
                T::Array[ModernTreasury::ContactDetailCreateRequest],
              external_id: T.nilable(String),
              ledger_account: ModernTreasury::LedgerAccountCreateRequest,
              metadata: T::Hash[Symbol, String],
              name: T.nilable(String),
              party_address: ModernTreasury::AddressRequest,
              party_identifier: String,
              party_name: String,
              party_type:
                T.nilable(
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::OrSymbol
                ),
              plaid_processor_token: String,
              routing_details:
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail
                ]
            }
          )
        end
        def to_hash
        end

        class AccountDetail < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail,
                ModernTreasury::Internal::AnyHash
              )
            end

          sig { returns(String) }
          attr_accessor :account_number

          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
              )
            )
          end
          attr_reader :account_number_type

          sig do
            params(
              account_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
            ).void
          end
          attr_writer :account_number_type

          sig do
            params(
              account_number: String,
              account_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
            ).returns(T.attached_class)
          end
          def self.new(account_number:, account_number_type: nil)
          end

          sig do
            override.returns(
              {
                account_number: String,
                account_number_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::OrSymbol
              }
            )
          end
          def to_hash
          end

          module AccountNumberType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            AU_NUMBER =
              T.let(
                :au_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            BASE_ADDRESS =
              T.let(
                :base_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            CLABE =
              T.let(
                :clabe,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            ETHEREUM_ADDRESS =
              T.let(
                :ethereum_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            HK_NUMBER =
              T.let(
                :hk_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            IBAN =
              T.let(
                :iban,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            ID_NUMBER =
              T.let(
                :id_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            NZ_NUMBER =
              T.let(
                :nz_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            OTHER =
              T.let(
                :other,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            PAN =
              T.let(
                :pan,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            POLYGON_ADDRESS =
              T.let(
                :polygon_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            SG_NUMBER =
              T.let(
                :sg_number,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            SOLANA_ADDRESS =
              T.let(
                :solana_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )
            WALLET_ADDRESS =
              T.let(
                :wallet_address,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::AccountDetail::AccountNumberType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end

        # Either `individual` or `business`.
        module PartyType
          extend ModernTreasury::Internal::Type::Enum

          TaggedSymbol =
            T.type_alias do
              T.all(
                Symbol,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType
              )
            end
          OrSymbol = T.type_alias { T.any(Symbol, String) }

          BUSINESS =
            T.let(
              :business,
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
            )
          INDIVIDUAL =
            T.let(
              :individual,
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
            )

          sig do
            override.returns(
              T::Array[
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::PartyType::TaggedSymbol
              ]
            )
          end
          def self.values
          end
        end

        class RoutingDetail < ModernTreasury::Internal::Type::BaseModel
          OrHash =
            T.type_alias do
              T.any(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail,
                ModernTreasury::Internal::AnyHash
              )
            end

          sig { returns(String) }
          attr_accessor :routing_number

          sig do
            returns(
              ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol
            )
          end
          attr_accessor :routing_number_type

          sig do
            returns(
              T.nilable(
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
              )
            )
          end
          attr_reader :payment_type

          sig do
            params(
              payment_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
            ).void
          end
          attr_writer :payment_type

          sig do
            params(
              routing_number: String,
              routing_number_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol,
              payment_type:
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
            ).returns(T.attached_class)
          end
          def self.new(routing_number:, routing_number_type:, payment_type: nil)
          end

          sig do
            override.returns(
              {
                routing_number: String,
                routing_number_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::OrSymbol,
                payment_type:
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::OrSymbol
              }
            )
          end
          def to_hash
          end

          module RoutingNumberType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            ABA =
              T.let(
                :aba,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            AU_BSB =
              T.let(
                :au_bsb,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            BR_CODIGO =
              T.let(
                :br_codigo,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CA_CPA =
              T.let(
                :ca_cpa,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CHIPS =
              T.let(
                :chips,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            CNAPS =
              T.let(
                :cnaps,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            DK_INTERBANK_CLEARING_CODE =
              T.let(
                :dk_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            GB_SORT_CODE =
              T.let(
                :gb_sort_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            HK_INTERBANK_CLEARING_CODE =
              T.let(
                :hk_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            HU_INTERBANK_CLEARING_CODE =
              T.let(
                :hu_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            ID_SKNBI_CODE =
              T.let(
                :id_sknbi_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            IL_BANK_CODE =
              T.let(
                :il_bank_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            IN_IFSC =
              T.let(
                :in_ifsc,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            JP_ZENGIN_CODE =
              T.let(
                :jp_zengin_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            MY_BRANCH_CODE =
              T.let(
                :my_branch_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            MX_BANK_IDENTIFIER =
              T.let(
                :mx_bank_identifier,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            NZ_NATIONAL_CLEARING_CODE =
              T.let(
                :nz_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            PL_NATIONAL_CLEARING_CODE =
              T.let(
                :pl_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SE_BANKGIRO_CLEARING_CODE =
              T.let(
                :se_bankgiro_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SG_INTERBANK_CLEARING_CODE =
              T.let(
                :sg_interbank_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            SWIFT =
              T.let(
                :swift,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )
            ZA_NATIONAL_CLEARING_CODE =
              T.let(
                :za_national_clearing_code,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::RoutingNumberType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end

          module PaymentType
            extend ModernTreasury::Internal::Type::Enum

            TaggedSymbol =
              T.type_alias do
                T.all(
                  Symbol,
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType
                )
              end
            OrSymbol = T.type_alias { T.any(Symbol, String) }

            ACH =
              T.let(
                :ach,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            AU_BECS =
              T.let(
                :au_becs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BACS =
              T.let(
                :bacs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BASE =
              T.let(
                :base,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            BOOK =
              T.let(
                :book,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CARD =
              T.let(
                :card,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CHATS =
              T.let(
                :chats,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CHECK =
              T.let(
                :check,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            CROSS_BORDER =
              T.let(
                :cross_border,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            DK_NETS =
              T.let(
                :dk_nets,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            EFT =
              T.let(
                :eft,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            ETHEREUM =
              T.let(
                :ethereum,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            GB_FPS =
              T.let(
                :gb_fps,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            HU_ICS =
              T.let(
                :hu_ics,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            INTERAC =
              T.let(
                :interac,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            MASAV =
              T.let(
                :masav,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            MX_CCEN =
              T.let(
                :mx_ccen,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NEFT =
              T.let(
                :neft,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NICS =
              T.let(
                :nics,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            NZ_BECS =
              T.let(
                :nz_becs,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            PL_ELIXIR =
              T.let(
                :pl_elixir,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            POLYGON =
              T.let(
                :polygon,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            PROVXCHANGE =
              T.let(
                :provxchange,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            RO_SENT =
              T.let(
                :ro_sent,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            RTP =
              T.let(
                :rtp,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SE_BANKGIROT =
              T.let(
                :se_bankgirot,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SEN =
              T.let(
                :sen,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SEPA =
              T.let(
                :sepa,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SG_GIRO =
              T.let(
                :sg_giro,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SIC =
              T.let(
                :sic,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SIGNET =
              T.let(
                :signet,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SKNBI =
              T.let(
                :sknbi,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            SOLANA =
              T.let(
                :solana,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            WIRE =
              T.let(
                :wire,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )
            ZENGIN =
              T.let(
                :zengin,
                ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
              )

            sig do
              override.returns(
                T::Array[
                  ModernTreasury::PaymentOrderCreateAsyncParams::ReceivingAccount::RoutingDetail::PaymentType::TaggedSymbol
                ]
              )
            end
            def self.values
            end
          end
        end
      end

      # One of `unreconciled`, `tentatively_reconciled` or `reconciled`.
      module ReconciliationStatus
        extend ModernTreasury::Internal::Type::Enum

        TaggedSymbol =
          T.type_alias do
            T.all(
              Symbol,
              ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus
            )
          end
        OrSymbol = T.type_alias { T.any(Symbol, String) }

        UNRECONCILED =
          T.let(
            :unreconciled,
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::TaggedSymbol
          )
        TENTATIVELY_RECONCILED =
          T.let(
            :tentatively_reconciled,
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::TaggedSymbol
          )
        RECONCILED =
          T.let(
            :reconciled,
            ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::TaggedSymbol
          )

        sig do
          override.returns(
            T::Array[
              ModernTreasury::PaymentOrderCreateAsyncParams::ReconciliationStatus::TaggedSymbol
            ]
          )
        end
        def self.values
        end
      end
    end
  end
end
